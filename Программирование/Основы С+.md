### 02.09.25
### #Леха
---
### Программа состоит из:

1. Директив процессора
2. Описаний
3. Функции
#### Главная функция называется main
---
####      Директива процессора  - определяет действия по преобразованию программы перед компиляцией а так же включает инструкции которыми компилятор следует во время компиляции

####     Объявления - описания переменных, функций, структур, классов и типов данных

####   Функция состоит из ==заголовка== и ==тела функции==

---
####    Заголовок состоит из:

1. Типа результата возвращаемого функцией
2. Имени функции
3. Списка параметров необходимых для выполнения функции

####    Тело функции
Заключается в операторные скобки { } и содержит описание локальных данных и операторы функции

---
### Пример программы

`директивы препроцессора`
`описание глобальных переменных`
`тип_результата main (параметры)`
`{`
`тело главной функции`
`}`

`тип_результата F1 (параметры 1) {`
`тело функции F1;`
`}`

`тип_результата F2 (параметры 2) {`
`тело функции F2;`
`}`

---
### Структура функции

тип_результата имя_функции (параметры)
{
описание данных;
оператор1;
оператор2;
}

    тип_результата - это тип значений которое функция должна вычислить

	имя_функции - имя с которым можно обращаться к этой функции

	параметры - список ее аргументов

---
### Директива препроцессора 

Память процессора является одним из ключевых в языке c++.

Процессор - это программа, действующая ка фильтр на этапе компиляции.

Исходная программа -> Препроцессор -> Расширенная исходная программа -> Компилятор

Перед тем, как попасть в компилятор, исходная программа проходит через препроцессор.

Основному тексту программы предшествуют директивы процессора (preprocessor directive), которые начинаются с символа решетки #, не являются выражением языка С++ (и потому не заканчивается точкой с запятой).

Команды (директивы) препроцессора представляют собой инструкции, записанные в исходном тексте программы, используемые для того, чтобы облегчить модификацию программ и сделать их независимыми от особенностей различных реализаций компилятора.

Например:
#include ‹имя файла>

Директивы могут быть записаны в любом месте исходного файла, но  их действие распространяется только от точки программы, в которой они записаны, до конца исходного файла.

Файлы, которые появляются в директивах, обычно заканчиваются на .h, что означает файл заголовков (header file). Файлы заголовков содержат объявления констант, переменных и функций, необходимых для работы программы.

Например:

#include <stdio.b>       функции стандартного ввода-вывода

#include <conio.h>      функции консольног вывода

#include <math.b>         стандартные математические функции 


Директива #include
Директива препроцессора #include позволяет включать в текст программы, написанной программистом, тексты других программ.

Эта директива имеет две формы записи:

#include ‹имя включаемого файла>

#include "имя включаемого файла"

В случае, когда имя_включаемого_файла (файла включений) записывается в угловых скобках, то поиск этого файла осуществляется в стандартных системных каталогах (каталоге подключаемых файлов (include directory), то есть в месте, где компьютерная система хранит все доступные для использования файлы заголовков. )

Например:
Finclude <stdio.h›   фрагмент на С
#include ‹iostream>  фрагмент на С++

Если же имя_ включаемого_файла указано в кавычках, то сначала поиск осуществляется в текущем каталоге и лишь затем в системных.

| #include "file2.h"  | Файл, содержащий объявления переменных и типов, созданных <br>программистом и используемых  в программе<br> |
| ------------------- | ----------------------------------------------------------------------------------------------------------- |
| #include"file2.сpp" | Файл, содержащий, например, объявления или описания функции, используемых в текущем модуле(файле)           |


Имя_включаемого_ файла может также содержать полный путь для его поиска, что наблюдается редко, так как это предполагает жесткую связь программы с конфигурацией файловой системы конкретной ЭВМ.


| #include <stdio.h>  | Функция стандартного ввода-вывода  |
| ------------------- | ---------------------------------- |
| #include <conio.h>  | Функция консольного ввода-вывода   |
| #include <math.h>   | Стандартные математические фуекции |
| #include <iostreаm> | Потоковый ввод/вывод               |

stdlib.h (standard library - стандартная библиотека) - заголовочный файл стандартной библиотеки общего назначения языка С, который содержит в себе функции:
- занимающиеся выделением памяти,
- контроль процесса выполнения программы,
- преобразования типов и другие.

Члены stdlib. h можно разделить на следующие категории:
- преобразования типов,
- управление памятью,
- контроль процесса,
- сортировка и поиск,
- математика.


## Преобразование типов

| Имя     | Описание                                                     |
| ------- | ------------------------------------------------------------ |
| atof    | Строка в число двойной точности (НЕ float)                   |
| atoi    | Строка в целое число                                         |
| atol    | строка в длинное целое число                                 |
| strtod  | строка в число двойной точности (double)                     |
| strtol  | строка в длинное целое число                                 |
| strtoul | строка в беззнаковое длинное целое число (unsigned long int) |

## Генерация псевдослучайных последовательностей


| Имя   | Описание                                                              |
| ----- | --------------------------------------------------------------------- |
| rand  | генерирует псевдослучайное значение                                   |
| srand | устанавливает начальное значение генератора псевдослучайных чисел<br> |

## Выделение и освобождение памяти



malloc
                              -выделяет память из кучи
calloc  


realloc
								- освобождает память обратно в кучу
Free


Директивы #define, #undef

Директива препроцессора #define позволяет заменять все вхождения указанного идентификатора какой-то определенной последовательностью символов.
Удобно использовать для объявления и определения констант, когда одно и то же значение (например, длина массива) используется в разных местах программы.

#define идентификатор последовательность символов

Например:

#define lin_arr 40
void main (void) {
int arr[lin_arr],  i;


for (i=0; islin_ar; i++) 
arr (i]=i+l;

---
## Тип void   (пустой)

Множество значений этого типа пусто.
Тип void используется для:
- определения функций, которые не  возвращают значения;
- для указания пустого списка аргументов функции;
- как базовый тип для указателей .
<<<<<<< HEAD


=======

---
### 08.09.25
### #Леха
Типы данных в С/С+ разделяются на основные и производные.

К основным типам относят:
﻿﻿﻿void (пустой тип),
﻿﻿﻿int (целый тип),
﻿﻿﻿float (вещественные числа с плавающей точкой),
﻿﻿﻿double (вещественные числа с плавающей точкой двойной точности),
﻿﻿﻿char (символьный тип).
﻿﻿﻿bool - логический.
﻿﻿﻿----

#### Символьный тип

Данные типа char в памяти компьютера всегда занимают 1 байт. Это связано с тем, что обычно под величину символьного типа отводят столько памяти, сколько необходимо для хранения любого из 256 символов клавиатуры.

Символьный тип может быть со знаком или без знака.

В величинах со знаком signed char можно хранить значения в диапазоне от - 128 до 127.
Соответственно значения переменных типа unsigned char могут находиться в диапазоне от 0 до 255

![[telegram-cloud-photo-size-2-5327847226803880291-y.jpg]]

При работе с символьными данными нужно помнить, что если в выражении встречается одиночный символ, он должен быть заключен в одинарные кавычки.
Последовательность символов, то есть строка, при использовании в выражениях заключается в двойные кавычки.

Например: 'F', 3', "Иван", "235"

---
### Целочисленный тип

Данные типа int в памяти компьютера могут занимать либо 2, 4 или 8 байт. Это зависит от разрядности процессора.
По умолчанию все целые типы считаются знаковыми, то есть спецификатор signed (знаковый) можно не указывать.
Спецификатор unsigned (беззнаковый)
позволяет представлять только положительные числа.

---
  
### Вещественный тип

Внутреннее представление вещественного числа в памяти компьютера отличается от представления целого числа. Число с плавающей точкой представлено в экспоненциальной форме

士mE士P

где m - мантисса (целое или дробное число с десятичной точкой), р- порядок (целое число).

Для того чтобы перевести число в экспоненциальной форме к обычному представлению с фиксированной точкой, необходимо мантиссу умножить на десять в степени порядок

Например: -6.42E+2 = -6,42*10^2

---
### Логический тип

Переменная типа bоо1 может принимать только два значения true (истина) или false (ложь).

Любое значение, не равное нулю, интерпретируется как true, а при преобразовании к целому типу принимает значение, равное 1.

Значение false представлено в памяти как 0.

---
### Тип void (пустой)

Множество значений этого типа пусто.

Tип void используется для:
- определения функций, которые не возвращают значения;
- для указания пустого списка аргументов функции;
- как базовый тип для указателей ;
- в операции приведения типов.

---

### Объявление переменных

Переменная - это поименованный участок памяти, в котором хранится значение определенного типа.

У переменной есть имя (идентификатор) и значение.
Имя служит для обращения к области памяти, в которой хранится значение.

Имя (идентификатор) - это совокупность букв, цифр и знаков подчёркивания, задающая имя переменной, название функции или ключевое слово в программе.

Язык С/С+ чувствителен к регистру (т.е. Sum и sum будут восприниматься как две разные переменные)

---
ТИП имя [-инициатор] ;

где, тип - ключевое слово, определяющее объём памяти (число байтов), выделенный для хранения значения переменной (как объекта программы), (int - целый, float, double - вещественный, char - символьный, bool - логический);

имя - уникальный идентификатор переменной, задающий символический адрес объекта программы в памяти ЭВМ;

инициатор - начальное значение переменной, которое может отсутствовать в описании.

---

![[Pasted image 20250908114402.png]]

---
## Выражения и функции c/c++

Выражение задает порядок выполнения действий над данными и состоит из операндов (констант, переменных, обращений к функциям), круглых скобок и знаков операций.

Выражения бывают:

• арифметические

a+b* sin(cos (x));

• сравнения ( отношения) a+c>=0 ;

логические atb<0 && x—y || true.

Операции делятся на унарные и бинарные

---
![[telegram-cloud-photo-size-2-5327847226803880377-y.jpg]]

---
### Условная операция

Для организации разветвлений в простейшем случае можно использовать условную операцию? :. Эта операция имеет три операнда и в общем виде может быть представлена

условие ? выражение] : выражение2;

Если условие истинно (не равно 0), то результатом будет выражение 1, в противном случае выражение2.

Обычно его используют в тех случаях, когда в зависимости от некоторых условий надо присвоить переменной одно из двух значений.

// Определение наименьшего числа.

#include ‹iostream>

void main (void)

int A, B, MIN;

cout<< "Введите первое число:" ;

cin>>A;

cout<<"\пВведите второе число: ";

MIN= (A<B) ? A : B;

cout <<"\ пНаименьшее число =

" < MIN <<"\n";

---
### Выражения и операции в C/C++
### #Чынгыз

**Преобразование типов и операция приведения**  
  
При построении выражений язык C/C++ допускает использование переменных и контраст разных типов . В этом случае при обработке выражения компилятор осуществляет автоматическое преобразование типов к одному, руководясь следующими основными правилами :
1) Операнды разных типов приводятся к более старшему типу. Этот процесс называется "повышением" типа. Старшинство типа операнда определяется исходя из размера памяти, отводимого под хранение данных. Перечислим типы данных в порядке убывания их старшинства: long double, double, float, unsigned long, long, unsigned int, int, short int, char..
2) При выполнении операции присваивания тип результата вычисления выражения в правой части приводится к типу переменной слева от знака присваивания. Это может привести как к "повышению", так и к "понижению" типа.
Преобразование, связанное с "повышением" типа, обычно происходит успешно и дает корректный результат. Преобразование же старших типов в младшие может привести к изменению результирующего значения вследствие выхода за возможный диапазон значений младшего типа

**Операции приведения типов**

Язык С/C++позволяет программисту самостоятельно управлять преобразованием типов данных.  (тип)выражения

Стандартные мат. функции в C/C++

| Функция   | Описание                                            | Пример         |
| --------- | --------------------------------------------------- | -------------- |
| sin(a)    | функция синус (задаётся в радианах)                 |                |
| cos(a)    | функция косинус                                     |                |
| tan(x)    | функция тангенс                                     |                |
| atan(x)   | арктангенс x в диапазоне (-п/2, п/2)                |                |
| log(x)    | нат. логарифм x (основанием явл. е- 2,78...)        | log(1.0)=0.0   |
| log10(x)  | десятичный логорифм x                               | log 10(10)=1   |
| asin(x)   | арксинус а , где -1.0<x<1.0                         | asin(1)=1.5708 |
| random(x) | выводит случайное число от 0 до аргумента функции x |                |
| exp2(x)   | значение числа 2, возведенную в степень x           |                |

Стандартные мат. функции

| Функция   | Описание                                                | Пример                                    |
| --------- | ------------------------------------------------------- | ----------------------------------------- |
| abs(x)    | модуль или абсолютное значение целого числа x           | abs (-3.0) = 3.0   abs (5.0)=5.0          |
| fabs(x)   | модуль числа с плавающей точкой                         |                                           |
| sqrt(a)   | корень кв из **а**, причем **а** не отрицательна        | sqrt (9.0)=3.0                            |
| pow(x,y)  | возведение x в степень y                                | pow (2.3) = 8                             |
| ceil(x)   | округление x до наименьшего целого , но не меньше чем x | ceil(12,4) ceil(-2,9)                     |
| floor(x)  | округление x до наибольшего целого , но не больше чем x | floor(2.3) =2.0  floor( -2.3)=-3/o        |
| fmod(x,y) | вычисление остатка от x/y                               | fmod(4.4, 7.5)= 4.4 fmod (7.5 , 4.4)= 3.1 |
| exp(x)    | вычисление экспоненты e в степени x                     | exp(0)=1                                  |

#define Pi 3.145292....  
  
const double Pi=3.145292...  
  

double Pi=M_Pi;  //  файл math."

double Pi=M_Pi;  //  файл maih."
3
Стандартные математические функции C++ определны в заголовочных файлах <math.h>

| Функция   | Описание                                               | пример           |
| --------- | ------------------------------------------------------ | ---------------- |
| sin(a)    | синус (a - в радианах)                                 |                  |
| cos(a)    | косинус                                                |                  |
| tan(x)    | тангенс                                                |                  |
| atan(x)   | арктангекс                                             |                  |
| log(x)    | натуральный лог                                        | log(1.0) = 0.0   |
| log10(x)  | десятичный лог                                         | Log10(10) = 1    |
| asin(x)   | арксинус                                               | asin(1) = 1.5708 |
| random(x) | рандом от 0 до X                                       |                  |
| exp2(x)   | значение числа 2 возведенного в степень X              |                  |
| abs(x)    | модуль или абсолют значение целого x                   |                  |
| fabs(x)   | модуль числа с плавающей точкой                        |                  |
| sqrt(a)   | корень квадртный из a, причем a не отрицательна        |                  |
| pow(x,y)  | возведение x в степень y                               |                  |
| cell(x)   | округление x до наименьшего целого но не меньше чем x  |                  |
| floor(x)  | округление x до наибольшего целого, но не больше чем x |                  |
| fmod(x,y) | вычисление остатка от x/y                              |                  |
| exp(x)    | вычисление экспоненты e^x                              |                  |
| fmax(x,y) | x и y это диапазон                                     |                  |
| fmin(x,y) | то же самое                                            |                  |
| log2(x)   | лог x по основанию 2                                   |                  |
| round(x)  | округление до целого                                   |                  |
| trunc(x)  | отбросить дробную часть                                |                  |


Стандартные математические функции C++ определны в заголовочных файлах <math.h>

| Функция   | Описание                                               | пример           |
| --------- | ------------------------------------------------------ | ---------------- |
| sin(a)    | синус (a - в радианах)                                 |                  |
| cos(a)    | косинус                                                |                  |
| tan(x)    | тангенс                                                |                  |
| atan(x)   | арктангекс                                             |                  |
| log(x)    | натуральный лог                                        | log(1.0) = 0.0   |
| log10(x)  | десятичный лог                                         | Log10(10) = 1    |
| asin(x)   | арксинус                                               | asin(1) = 1.5708 |
| random(x) | рандом от 0 до X                                       |                  |
| exp2(x)   | значение числа 2 возведенного в степень X              |                  |
| abs(x)    | модуль или абсолют значение целого x                   |                  |
| fabs(x)   | модуль числа с плавающей точкой                        |                  |
| sqrt(a)   | корень квадртный из a, причем a не отрицательна        |                  |
| pow(x,y)  | возведение x в степень y                               |                  |
| cell(x)   | округление x до наименьшего целого но не меньше чем x  |                  |
| floor(x)  | округление x до наибольшего целого, но не больше чем x |                  |
| fmod(x,y) | вычисление остатка от x/y                              |                  |
| exp(x)    | вычисление экспоненты e^x                              |                  |
| fmax(x,y) | x и y это диапазон                                     |                  |
| fmin(x,y) | то же самое                                            |                  |
| log2(x)   | лог x по основанию 2                                   |                  |
| round(x)  | округление до целого                                   |                  |
| trunc(x)  | отбросить дробную часть                                |                  |

![[IMG_3572.jpeg]]

---
# Значение параметров спецификаций, 15.09.25
### #Рома 


**Строка форматов** содержит символы, которые будут выводиться на экран , или запрашиваться с клавиатуры, и так называемые спецификации.

**Спецификации** - это строки, которые начинаются символом % и выполняют управление форматированием:

==% флаг ширина  .  точность модификатор тип==

Параметры *флаг, ширина, точность и модификатор* в спецификациях могут отсутствовать.
Параметр **тип** (вводимых/выводимых данных) является обязательным

| Параметр | Назначение                                                                                            |
| :------: | :---------------------------------------------------------------------------------------------------- |
|    -     | Выравнивание числа влево. Правая сторона дополняется пробелами. По умолчанию выравнивание вправо      |
|    +     | Перед числом выводится знак «+» или<br>((-))                                                          |
|  Пробел  | Перед положительным числом выводится пробел, перед отрицательным «-»                                  |
|    #     | Выводится код системы счисления: 0 - перед восьмеричным числом.<br>Ох -перед шестнадцатеричным числом |

---
## Неформатированный ввод/вывод

Для ввода-вывода символов и строк можно использовать соответствующие функции стандартного ввода-вывода (*stdio.h*)

- [b] Функция ввода символов (без параметров)
`getchar()`

Определение ASCII-код нажатой клавиши, записывает его в буфер ввода *stdin* а после нажатия клавиши Enter передает в оперативную память для ввода в переменную описанную с типом *int* или *char*

- [b] Функция вывода символа 
`puthar (ch)`

Преобразует ASCII-код записанный в переменной **ch** (тип int или char) в символ выводимый на экран


### Пример. Ввести и вывести символ, а затем определить его коды (10-чный, 8-чный, 16-чный ).

	`#include <stdio.h> 
	#include <locale.h> 
	int main () {
	char ch; /* переменная для символа *
	setlocale (IC_ALL, "Russian") ;
	printf ( "Нажмите клавишу символа, а затем
	Enter: ") ;
	ch = getchar ( ); /* ввод кода символа* printf ("\n Вывод    символа:") ;
	putchar (ch) ;
	printf ("\пСимвол\t10-чный\ t8-чный\t16-чный
	коды \n") ;
	printf (":c\t%d\t%o\t8x", ch, ch, ch, ch) ; 
	return 0;
	}`

---
- [b] Функция ввода строки символов
`gets(string)`

Где *string* - указатель (адрес) для ввода строки символов, например, имя массива символов.

В отличие от функции **scanf ("gs", string)** , которая вводит символы до первого пробела, функция **gets (string)** вводит все символы, включая пробелы.

- [b] функция вывода строки символов
`puts(string)`

Где *string* - либо сама строка, либо указатель (адрес) области памяти, откуда выводится строка, например, имя массива символов.

Эта функция аналогична функции **printf ("&s", string)** , но при этом автоматически выполняет перевод курсора экрана на новую строку.

### Пример. Ввод-вывод строк символов.
	`#include <stdio.h>
	#include <locale.h>
	int main ()
	{
	char name [30]; // Описание символьного массива пате
	setlocale (LC_ALL, "Russian");
	puts ("Введите Вашу фамилию и имя:"); / Вывод строки 
	gets (name); // Ввод фамилии и имени в массив printf                   ((nЗдравствуйте, ");        Вывод сообщения 
	puts (name) : Вывод строки из массива
	return 0;
	}

При вводе с клавиатуры строки Петров Иван, в массив символов пате будут введены оба символа, а при использовании функции scanf("/s", пате) будет введено первое слово.

---

### Консольный ввод-вывод

Функции консольного ввода-вывода не используют входной буфер stdin для ввода данных. Все символы, вводимые с клавиатуры, доступны программе немедленно, что предоставляет дополнительные возможности при обработке данных в программе, при подключении директивы препроцессора **#include<conio.h>**
- [b] Функция ввода символа (без отображения)
`getch ()`

Считывает код символа нажатой клавиши и не отображает символ на экране.
Это свойство можно использовать в двух случаях:
1. Для ввода невидимых символов в память и использования их для проверки пароля программы:
``char ch; * описание спивольной переменной 
`puts ("Нажмите любую символьную клавишу.") ; 
`ch = getch () ; * ввод кода символа без его отображения``
`Символ и его кол могут быть выведены на экран * 
`printf ("пСимвол: 8с (код: 8d)", ch, ch) ;``


- [b] Функция ввода символа (с отображения)
`getche ()`

Выполняет небуферизированный ввод символа в отличие от функции **getchar ()** и его отображение в отличие от функции **getch()**

- [b] Функция очистки экрана результатов 
`clrscr ()`

Очищает экран данных от предыдущих сообщений и результатов

Эту функцию следует использовать в начале своей программы после описания переменных а также в тех случаях когда экрана данных не достаточно для ввода всех результатов и их приходится "листать"

---
### Объектно ориентированные средства ввода/вывода 

Описание объектов для управления вводом-выводом содержится в заголовочном файле **iostream**

При подключении этого файла с помощью директивы
`#include <iostream> в программе автоматически создаются объекты-потоки`

- [b] cin - для ввода с клавиатуры
- [b] cout - для вывода на экран
- [b] <<и>>  - операции помещения в поток (вывод) и чтения из потока (ввод)

**Поток** - виртуальный канал связи создаваемый в программе для передачи данных

Потоки означают последовательность данных передаваемых из одной части компьютера в другую

<<,>> - оператор перенаправления потока и разделитель между элементами ввода и вывода

---

### #Чынгыз 
#### **17.09.25**
При выводе чисел с плавающей точкой возникает несколько проблем:
1)очень большие и очень маленькие вещественные числа выводятся в экспоненциальной форме;
2)если значение является целочисленным, то СН не выводит десятичную точку
3)довольно часто требуется управлять количеством десятичных разрядов в дробной части.

Решить 1) и 2) проблемы можно включив в программу перед выводом вещественных значений следующие операторы:
cout/setf(ios::fixed, ios::fioatfield) //Установка формата
                           // вывода чисел
cout.setf(ios.:showpoint);            //с плавающей точкой

**cout. setf** - метод (функция) объекта cout
﻿﻿**cout.setf(ios::fixed, ios::floatfield)** - функции обеспечивает
печать вещественных чисел в десятичной , а не в экспоненциальной форме.
﻿﻿cout.setf(ios::showpoint) - задает печать десятичной точки, даже если дробная часть =0.
**3-я проблема** - контроль числа десятичных позиций при выводе решается с помощью манипулятора Setprecision (n).
Значение Setprecision(n) остается в силе для всех последующих элементов выходного потока.( до тех пор, пока это значение не будет изменено при повторном обращении к Setprecision) **Пример:**
( float x=310.5, y=4.876;
cout<< setw(10) <<Setprecision (5) <<x<<endl; cout<< setw(6) <<Setprecision (1) <<y;
Результат:
310.50000
4.8

#### Множественное присваивание
В С существует возможность присваивания нескольким переменным одного и того же значения. Такая операция называется множественным присваиванием и в общем виде может быть записана так:
*имя_перем 1= имя перем 2=...= имя_перем N =значение;*
например:
a=b=c=3.14159/6

#### Составное присваивание
переменная OPER = выражение
Что равносильно переменная = переменная OPER выражение;
Onepaции: +=, -=, звездочка плюс,/=,%=,&=,^=, >>=,<<=, !=
называют *составным присваиванием.*
В таких операциях при вычислении выражения, стоящего справа, используется значение переменной из левой части, например, так:
Например:
x+=р; //Увеличение х на р, или х=х+р. 
х-=р; /Уменьшения х на р, или о н х=х-р.
Х*=₽ ; //Умножение х на р. или х=х*р. 
х/=р; //Деление х на р, или х=х/р.
SUM<<=N; // SUM=SUM<<N;

---
### Использование стандартного пространства имён
##### Листинг использования std::cout
`#include <iostream>
`int main ( )
`{`
`std: : cout « "Привет \n"; std:: cout<<"Введите число до 5"<< 5<<"\n" ;`
`std:: cout << 8+5<< std: `:endl;`
``
`.  .  .   ;``
`return 0;`
`}`

Использование идентификатора std:: перед операторами cout и endl (end line) надоедает. С помощью идентификатора пространства имен этого можно избежать. Стандарт ANSI допускает два способа решения этой задачи.

##### 2 способ:
Заключается в указании компилятору на то, что будет использовано стандартное пространство имен, т.е, любой объект, происхождение которого не указано, считается взятым из стандартного пространства имен.

В данном случае использовано определение пространства имен
**using namespace std;**

*Пример 3:*
`#include <iostream>
`void main ()`
`{`

`using namespace std;`
`cout « "Привет \n";`
`cout «"Введите число до 5" «< 5 <<"\п" ;`
`cout << 8+5<< endl;``
`.  .  .    ;
`}`

---
## Манипуляторы
*Манипуляторы используются исключительно в выражениях ввода/ вывода.*

Манипулятор языка С+ представляет собой объект, внешне похожий на объект данных, но ведущий себя как функция.
Подобно функции, манипулятор вызывает определенное действие, но аналогично объекту данных, может возникать среди последовательности операторов вставки.


---
# Ветвление процессов, 24.09.25
### #Рома 
---
### Создание блоксхем
### #Чынгыз 

Конфигурация и размеры блоков, а также порядок графического оформления блок-схем регламентированы ГОСТ 19002-80 и ГОСТ  
19003-80  
﻿﻿ГОСТ 19002-80. ЕСПД. Схемы алгоритмов и программ. Правила выполнения.  
﻿﻿ГОСТ 19003-80. ЕСПД. Схемы алгоритмов и программ. Обозначения условные графические.
﻿
﻿**Слияние линий потока** 
Место слияний потока обозначено точкой.  
Применяется в случае слияния линий потока, каждая из которых направлена к одному и тому же блоку на схеме﻿

**Размеры основных блоков**
Размер а должен выбираться из ряда 10, 15, 20 мм.  
Допускается увеличивать размер а на число, кратное 5.  
Размер b = 1,5a.

блок **Процесс** - выполнение операций или группы операций, в результате которых изменяется значение, форма представления или расположение данных

блок **Решение**- выбор направления выполнения алгоритма или программы в зависимости от некоторых переменных условий
![[Drawing 2025-10-06 11.40.37.excalidraw]]

блок  **Модификация** - выполнение операций, меняющих команды или группу команд, изменяющих программу
![[Drawing 2025-10-06 12.02.08.excalidraw]]
**блок Предопределенный процесс**-использование ранее созданных и отдельно описанных алгоритмов или программ

**блок Ввод-Вывод**- преобразование данных в форму, пригодную для обработки (ввод) или отображения результатов обработки (вывод)

**блок Межстраничный соединитель** -  
указание связи между разъединенными частями схем алгоритмов и программ, расположенных на разных листах

**Создание программы**- это систематический процесс, состоящий из определенных этапов.

**Спецификация программы**  
(Specification)- это формализованное представление требовании, предъявляемых к программе, которые должны быть удовлетворены при ее разработке, а также описание задачи, условия и эффекты действия без указания способа ее достижения


**В результате этого процесса разработчик получает программу:**
• Эффективную, т.е. экономно расходующую ресурсы и быстро выполняемую. Эффективность предполагает, что алгоритм и программа составлены так, чтобы минимизировать по возможности ресурсы вычислительной системы, необходимые для её решения;
### Правила оформления программы
**Правило 1**: количество операторов в строке должно быть равно одному  
Пример c/c++:  
x=0;  
while (x<=pi)  
{  
y=sin(x); cout<<"y="<<<<end!;  
}

**Правило 2**: все операторы, входящие в составной, должны быть сдвинуты вправо (клавиша Tab).  
Пример c/c++:  
if (a<b) {  
J=m;  
Tab i=l;  
for (k=o; k<N; k++) {  
c[k]+=(m-l);  
Tab u[k-j]=2*j;  
if (i>a) {  
Tab   
→ break;  
}  
}  
}

**Правило 3**:операторные скобки, относящиеся к одному блоку, должны располагаться следующим образом: открывающаяся скобка должна находиться на той же строчке, что и следующий до блока оператор, а закрывающая должна находиться строго на одной линии по вертикали с началом оператора, предшествующем данному составному

**Правило 4**: В конце строки пробелов быть не должно. Пробелы полезны вокруг знака какой-нибудь операции.  
Пример с/c++:  
for (x_=_1;x>_N;--) 1  
int tmp;  
tmp_=_funclx, argl,_arg2);  
}

**Правило 5**: Пустые строки  
﻿﻿обязательны пустые строки перед и после определений подпрограмм (функций и процедур);  
﻿﻿логические части подпрограмм нужно отделять друг от друга пустой строкой (например, цикл от предшествующих или последующих операторов)
﻿﻿
﻿﻿**Пример c/c++:**  
int func l(void)  
{  
return l;  
// пустая строка (лучше комментарий к функции)  
int func2 (void)  
return 2;  
// пустая строка  
int main 0

**Правило 6**: Тип у переменной следует писать для каждой из них.  
На одной строчке - одна переменная.  
Неправильно:  
int a,b,c; float *d, test,r,aa;  
Правильно:  
int a;  
  
int b;  
  
int C;  
  
float *d;  
  
float test;  
  
float r;  
  
float aa;

**Правило 7**: Идентификаторы (имена переменных, типов, подпрограмм) должны быть значимыми настолько, чтобы читающий текст программы мог понимать назначение всех переменных и т.д. без присутствия рядом автора  
int kol_vo; float summa;х

**Правило 8**: Массивы с заранее предопределенными значениями ( если их не требуется вводить с клавиатуры или из файла) не инициализировать операторами присваивания, а делать это с использованием инициализаторов и типизированных констант в языке с/с++.

**Правило 9:** 
Программа без параметров- почти всегда  
заведомо плохая программа.  
у функций должны быть аргументы.  
Функция, использующая глобальные переменные - почти наверняка плохая, ибо ситуация, когда внутри функции необходимо использовать глобальную переменную, крайне редки.  
Функции должны быть короткими - 2 экрана (50 строк) максимум. Единственное оправдание длинной функции - это наличие в ней оператора множественного выбора с большим числом альтернатив.

**Правило 10:** 
Если функция может потенциально завершиться неудачно, то эту ситуацию следует проверять.  
Если возникшая ошибка такова, что  
программа (подпрограмма) далее выполняться не может, условие проверки на ошибку лучше писать так, чтобы оно было истинным, если ошибка произошла, и алгоритм строить так, чтобы избегать оборота else в операторе if. Помните, что из подпрограммы можно выйти в любом месте, не обязательно в конце её текста.

**Правило 11:**  
Организация данных в программе -  
это вопрос не менее важный, чем алгоритмическая структурированность программы.  
Для структуризации данных существуют типы данных, структуры (записи) и классы. Сложная программа, в которой нет ни одного массива или структур - это плохая программа.

---
## Цикл
### #Чынгыз 
**Циклом** называется многократно выполняемая группа операторов. 

**Параметр цикла** - это величина, которая при выполнении каждого цикла изменяется на величину шага.

**Эталон цикла** - некоторая постоянная величина с которой при каждом выполнении цикла сравнивается параметр цикла и как только они окажутся в заданном соотношении происходит выход из цикла